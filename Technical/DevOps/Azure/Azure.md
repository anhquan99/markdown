# Implement containerized solutions
- Azure container registry (ACR)
	- Use cases
		- Scalable orchestration system that manage containerized applications across clusters of host, including K8s, DC/OS and Docker Swarm.
		- Azure services that support building and running applications at scale, including Azure Kubernetes Service (AKS), App Service, Batch, Service Fabric, ...
	- Tier
		- Basic: provide the same with 2 other tiers ( Azure Active Directory authentication integration, image deletion, and webhooks) for learning and lower usage scenarios.
		- Standard: provide increased storage and image throughput.
		- Premium: provide the highest amount of resources, adding feature such as geo-replication for managing a single registry across multiple regions, content trust for image tag signing, and private endpoints to restrict access to the registry.
	- Storage capabilities
		- Encryption-at-rest: Azure automatically encrypts an image before storing it, and decrypts it on the fly.
		- Regional storage: ACR stores data in the region where the registry is created, except for some regions. If a regional outage occurs, the registry data may become unavailable and isn't automatically recovered, this issue is solved by geo-replication.
		- Zone redundancy: premium service tier feature, replicate your registry to a minimum of 3 separate zones in each enabled region.
		- Scalable strage.
	- ACR Tasks 
		- Quick task: build and push a single container image to a container registry on-demand without needing a local Docker Engine installation. Think `docker build`, `docker push` in the cloud.
		- Automatically triggered tasks: build image base on triggers
			- Trigger on source code update: when the code repository updated, an ACR Task creates webhook trigger a build of the container image defined in the repo.
			- Trigger on base image update: when the updated base image is pushed to your registry, or a base image is updated in a public repo, ACR Tasks can automatically build any application image based on it.
			- Trigger on a schedule: useful for running container workloads on a defined schedule, or running maintenance operations or tests on images pushed regularly to your registry.
	- Image platforms
		- Linux:
			- amd64
			- arm
			- arm64
			- 486
		- Windows:
			- amd64
# Implement Azure Service web apps
- Support service
	- Built-in auto-scale support: depending on the usage of the web app, the web service itself can scale up/down or scale out/in.
	- CI/CD
	- Deployment slots
	- App Service on Linux
- Limitations:
	- App Service on Linux is not supported on Shared pricing tier.
- App Service plan defines:
	- OS
	- Region
	- Number of VM instances
	- Size of VM instances
	- Pricing tier (Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3, Isolated, IsolatedV2)
- Runs and scales (except for Free and Shared tier)
	- An app runs on all the VM instances configured in the App Service plan.
	- If multiple apps are in the same App Service plan, they all share the same VM instances.
	- If you have multiple deployment slots for an app, all deployment slots also run on the same VM instances.
	- If you enable diagnostic logs, perform backups, or run WebJobs, they also use CPU cycles and memory on these VM instances.
- Deployment
	- Automated deployment
	- Manual deployment
- Built-in authentication
	- How it works?
		- Authenticates users and clients with the specified identity provider(s)
		- Validates, stores, and refreshes OAuth tokens issued by the configured identity provider(s)
		- Manages the authenticated session
		- Injects identity information into HTTP request headers
# Implement Azure functions
# Develop solution Azure Cosmos DB
- It's a fully managed NoSQL database designed to provide low latency, elastic scalability of throughput, well-defined semantics for data consistency, and high availability.
- Consistency levels
	 ![[Pasted image 20230610211654.png]]
	 - Strong consistency: Users are always guaranteed to read the latest committed write.
	 - Bounded staleness consistency: the reads might lag behind writes by at most "K" versions of an item or by "T" time interval, whichever is reached first.
	 - Session consistency: monotonic reads and writes.
	 - Consistent prefix consistency: if the operation performs on doc_1 and doc_2 you will get doc_1 ver 1 and doc_2 ver 1 or doc_1 ver 2 and doc_2 ver 2 but never doc_1 ver 1 and doc_2 ver 2.
	 - Eventual consistency: there's no guarantee for reads. In the absence of any further writes, the replicas eventually converge. It's the weakest form of consistency.
- Request units (RUs):
	  ![[Pasted image 20230610214109.png]]
	- Represents the system resources such as CPU, IOPS, and memory that are required to perform the database operations supported by Azure Cosmos DB.
	- Azure Cosmos DB account modes:
		- Provisioned throughput mode: you provision the number of RUs for your application.
		- Serverless mode: you get billed for the number of RUs consumed.
		- Autoscale mode
# Develop solution Blob storage
- Azure Blob storage is object storage solution for the cloud. It's optimized for storing massive amounts of unstructured data.
- Types of storage accounts:
	- Standard: general-purpose v2 account.
	- Premium: use SSD
		- Block blob
		- Page blobs
- Access tiers for block blob data:
	- Hot: it's the highest storage costs, but the lowest access cost. New storage accounts are created in the hot tier by default
	- Cool: infrequently accessed and stored for at least 30 days. It has the lower storage costs and higher access costs compare to the hot tier.
	- Archive: only for individual block blobs. It's the highest access costs but lowest storage costs.
- Storage resource types:
	- Storage accounts
	- Containers: is a set of blobs, similar to a directory in a file system.
	- Blobs:
		- Block blobs
		- Append blobs: optimized for append operations. Ideal for logging data.
		- Page blobs: store virtual hard drive (VHD)
- Security feature:
	- Automatically encrypt using Storage Service Encryption (SSE).
	- Manage operations with Azure Active Directory (Azure AD) and Role-Based Access Control (RBAC).
	- Data can be secure in transit between an application and Azure by using Client-Side Encryption, HTTPS, or SMB 3.0.
	- Disk encrypt by using Azure Disk Encryption.
	- Delegate access to the data objects in Azure Storage can be granted using a shared access signature.
- Encryption key management:
	- Customer-managed key.
	- Customer-provided key.
# User authentication and authorization

- Microsoft identity platform:
	- Helps you build applications for users or customers to sign in using Microsoft identities or social accounts, and provide authorized access to your own APIs or Microsoft APIs like Microsoft Graph.
	- Components:
		- OAuth 2.0 and OpenID Connect standard-compliant authentication help application authenticate through:
			- Work or school accounts, provisioned through Azure AD.
			- Personal Microsoft account.
			- Social or local accounts using Azure AD B2C.
		- Open-source libraries: Microsoft Authentication Libraries (MSAL).
		- Application management portal: a registration and configuration experience in the Azure portal, along with the other Azure management capabilities.
		- Application configuration API and PowerShell.
	- Service principals:
		- Single tenant: only accessible in your tenant.
		- Multi tenant: accessible in other tenants.
	- Application object: an Azure AD application is defined by its one and only application object.
	- Service principle object:
		- To access resources secured by Azure AD tenant, the entity that requires access must be represented by a security principal, this is true for both users (user principal) and applications (service principal).
		- Types of service principal:
			- Application
			- Managed identity
			- Legacy
	- Relationship between application objects and service principals:
		- An application object has:
			- A one to one relationship with the software application.
			- A one to many relationship with its corresponding service principal object(s).
	- Permission types:
		- Delegated permissions make call to the resources on behave of the signed user.
		- App-only access permissions.
	- Consent types:
		- Static user consent ask for permission when the application has not granted permission, but it has some issues:
			- Request all the permission for the first time, this may lead to a long list of permissions that discourages end users from approving the consent.
			- Application needs to know all the resources it will access ahead of time, this is hard.
		- Incremental and dynamic user consent:
			- Ask to the minimum permission first then ask for permission if required later.
			- A big challenge for permissions that require admin consent, since the admin consent experience doesn't know about those permissions at consent time. If you require admin privileged permissions or if your app uses dynamic consent, you must register all of the permissions in the Azure portal (not just the subset of permissions that require admin consent).
		- Admin consent
	- Conditional check:
		- Enables developers and enterprise customers to protect services in a multitude of ways:
			- Multifactor authentication.
			- Allowing only Intune enrolled devices to access specific service.
			- Restricting user locations and IP ranges.
- MSAL:
	- Provides secure access to Microsoft Graph, other Microsoft APIs, third-party web APIs, or your own web API, gives you many ways to get tokens and benefits:
		- No need to directly use the OAuth libraries or code against the protocol in your application.
		- Acquires tokens on behalf of a user or on behalf of an application (when applicable to the platform).
		- Maintains a token cache and refreshes tokens for you when they're close to expire, you don't need to handle.
		- Helps you set up your application from configuration files.
		- Helps you troubleshoot your app by exposing actionable exceptions, logging, and telemetry.
	- Authentication flows:
		- Authorization code: obtain tokens in the name of the user.
		- Client credentials: service applications run without user interaction.
		- On-behalf-of: application calls a service/web API, which in turns calls Microsoft Graph.
		- Implicit: used in browser-based applications.
		- Device code: Enables sign-in to a device by using another device that has a browser.
		- Integrated Windows: Windows computers silently acquire an access token when they're domain joined.
		- Interactive: Mobile and desktops applications call Microsoft Graph in the name of a user.
		- Username/password.
	- Shared access signatures (SAS):
		- Is a signed URI that contains a special set of query parameters to access storage resources.
		- Types of shared access signatures:
			- User delegation SAS: secured with Azure AD credentials and also by the permissions specified for the SAS, this applies to Blob storage only.
			- Service SAS: secured with the storage account key, delegate access to a resource in Azure Storage service: Blob storage, Queue storage, Table storage or Azure Files.
			- Account SAS: secured with the storage account key, delegate access to resources in one or more of the storage services. All of the operations available via a service or user delegation SAS also available via an account SAS.
			- Note: Microsoft recommends using Azure AD credentials when possible as a security best practice rather than using the account key.
		- URI components: ![[Pasted image 20230630224225.png]]
		- Best practice to reduce the potential risks of using SAS:
			- Always use HTTPS.
			- The most secure SAS is a user delegation SAS. Use it wherever possible because it removes the need to store your storage account key in code. You must use Azure Active Directory to manage credentials. This option might not be possible for your solution.
			- Set expiration time for SAS, if SAS key is stolen it can be exploited for a short time.
			-  Apply the rule of minimum-required privileges.
			- Find another solution beside SAS when not situation can not accept the risks of using SAS.
		- When to use SAS ?
			- A common scenario where a SAS is useful is a service where users read and write their own data to your storage account.
		- Stored access policy:
			- Provide extra level of control over service-level SAS on the server side.
			- Storage resources support stored access policies:
				- Blob containers.
				- File shares.
				- Queues.
				- Tables.
- Microsoft Graph:
	- Is the gateway to data and intelligence in Microsoft 365.
	- Components facilitate the access and flow of data:
		- REST APIs or SDKs to access Microsoft Graph endpoint `https://graph.microsoft.com`.
			- HTTP methods:
				- GET 
				- POST
				- PATH: update a resource with new value.
				- PUT: replace a resource with a new one.
				- DELETE
		- Microsoft Graph connectors work in the incoming direction, delivering data external to the Microsoft cloud into Microsoft Graph services and applications.
		- Microsoft Graph Data Connect provides a set of tools to streamline secure and scalable delivery of Microsoft Graph data to popular Azure data stores.
	- Apply best practices:
		- Authentication:
			- Use HTTP Authorization request header.
			- Graph client constructor when using Microsoft Graph client library.
		- Consent and authorization:
			- Use the least privilege.
			- Use the correct permission type based on scenarios.
			- Consider end user and admin experience.
			- Consider multi-tenant applications.
				- Tenant admins can disable the ability for end users to consent to application.
				- Tenant admins can set custom authorization polices.
			- Handle responses effectively:
				- Pagination.
				- Evolvable enumerations.
			- Storing data locally.
# Secure Azure solutions
- Azure key vault is used for storing and accessing secrets.
- Problem solves:
	- Secrets management.
	- Key management.
	- Certificate management.
- Tiers:
	- Standard: encrypts with a software key.
	- Premium: includes hardware security module (HSM) protected keys.
- Benefits:
	- Centralized application secrets
	- Securely store secrets and keys
	- Monitor access and use
	- Simplified administration of application secrets
- Authentication with Azure key vault:
	- Manage identities for Azure resources: assign an identity to the resources that has access to key vault. This is recommended as a best practice.
	- Service principal and certificate: Microsoft is not recommend is approach because the application owner or developer must rotate the certificate.
	- Service principal and secret: another not recommended approach because it's hard to automatically rotate the bootstrap secret that's used to authenticate to key vault.
- Encryption of data in transit: Azure key vault enforces TLS protocol to protect data when it's traveling between Azure key vault and clients.
- Best practices:
	- Use separate key vaults
	- Control access to your vault
	- Backup
	- Logging
	- Recovery options: turn on soft-delete and purge protection if you want to guard against force deletion.
# Azure caching solutions
- Azure cache for Redis
	- Key scenarios:
		- Data cache
		- Content cache
		- Session store
		- Job and message queuing
		- Distributed transactions
# Event-based solutions
- Azure event Grid is a serverless event broker that you can use to integrate applications using events
	- 5 concepts in event grid
		- Event: what happened.
		- Event sources: where the event took place.
		- Topic: the endpoint publishers send events.
		- Event subscriptions: the event router, it can route to multiple handler. Subscriptions are also used by handler to filter incoming request.
		- Event handler: the app or service to handle event.
	- Event schemas:
		- Event schema: use `"content-type" : "application/json; charset=utf-8` 
		- Cloud schema: use `"content-type" : "application/cloudevents+json"`
	- Event delivery durability:
		- Note: event grid doesn't guarantee order for event delivery, so subscribers may receive them out of order.
		- Retry schedule:
			- If error occur when sending event, event grid will consider dropping the event to dead-letter queue or drop the event. The dead-letter queue is not config by default.
			- Event grid will wait for 30 seconds for the response, after 30 seconds the event grid will retry. Event grid uses an exponential backoff retry policy.
		- Retry policy:
			- Maximum number of attempts: must be 1 to 30, default value is 30.
			- Event time to live (TTL): must be 1 to 1440, default value is 1440 minutes.
		- Output batching:
			- Max events per batch
			- Preferred batch size in kilobytes
		- Delayed delivery: if an endpoint experiences delivery failures, event grid begin to delay the delivery and retry.
		- Dead-letter event: after a certain time of retries or TTL, the event is sent to a storage account.
	- Control access to events
		- Build-in roles
			- Event grid subscription reader: lets you read event grid event subscriptions.
			- Event grid subscription contributor: lets you manage event grid event subscription operations.
			- Event grid contributor: lets you create and manage event grid resources.
			- Event grid data sender: lets you send events to event grid topics.
		- Permissions for event subscriptions: for event handler isn't a WebHook (such as an event hub or queue storage)
			- System topics: `/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}`
			- Custom topics: `/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/Microsoft.EventGrid/topics/{topic-name}`
	- Filter events
		- Event type filtering
		- Subject filtering
		- Advanced filtering
# Message-based solutions
- Azure support 2 types of queue mechanism
	- Service Bus queues: is a fully managed enterprise integration message broker, which decouple applications and services.Data is transferred between different applications and services using messages.
		- Consideration when using:
			- Receive messages without having to poll the queue, Service Bus support long-polling receive operation using the TCP-based protocols
			- Required FIFO
			- Automatic duplicate detection
			- Your application process messages as parallel long-running streams (messages are associated with a stream using the session ID property on the message). In this model each node in the consuming node, the node can examine the state of the application stream state using transaction.
			- Required transactional behavior and atomicity when send or receiving multiple messages from a queue.
			- Handle message > 64 KB and < 256 KB.
		- Queues
			- Load-leveling enables producers and consumers to send and receive messages at different rates. The benefit for application or service is it can handle messages at average load instead of peak load.
		- Receive modes:
			- Receive and delete: marks the message is consumed as the consumer request and return it to the consumer. This mode is not for failure tolerance.
			- Peek lock: if the message is unable to process, the Service Bus service abandon the message. Service Bus unlocks the message and make it available to be received again. There is a timeout associated with the lock.
				1. Find the next message to be consumed, lock is it to prevent other consumers from receiving it, then return to the application or service.
				2. After the application or service consumes the message, it will tell the message queue the message has been completed, then the message queue mark the message is consumed.
			- Topics and subscriptions: provide on-to-many form of communication in a publish and subscribe pattern.
			- Rules and actions
	- Storage queues
		- Consideration when using:
			- Store more than 80 GBs of message.
			- Required keeping track of the progress message
# Application insights
- Application insights is an extension of Azure Monitor provides Application Performance Monitoring (APM) tools are useful to monitor applications from development, test, and production in following ways:
	- Proactively understand how an application os performing.
	- Reactively review application execution data to determine the cause of an incident.
- Feature:
	- Live metrics.
	- Availability.
	- Github or Azure DevOps integration.
	- Usage.
	- Smart detection.
	- Application map.
	- Distributed tracing.
- Monitors:
	- Request rates, response times and failure rates.
	- Dependency rates, response times, and failure rates
	- Exceptions.
	- Page views and load performance.
	- AJAX calls.
	- User and session counts.
	- Performance counters.
	- Host diagnostics.
	- Diagnostics trace logs.
	- Custom evnts and metrics.
- Log-based metrics:
	- Log-based metrics are translated into Kusto queries from stored events.
	- Standard metrics are stored as pre-aggregated time series.
- Availability test
	- URL ping test
	- Standard test: include SSL certificate validity, proactive lifetime check.
	- Custom TrackAvailability
	- Multi-step test (only available through Visual Studio 2019)
# API management
- Components:
	- API gateway:
		- Accepts API call and routes them to appropriate backends.
		- Verifies API keys and other credentials presented with requests.
		- Enforces usage quotas and rate limits.
		- Transforms requests and responses specified in policy statements.
		- Caches responses to improve response latency and minimize the load on backend services.
		- Emits log, metrics and traces for monitoring, reporting and troubleshooting.
	- Management plane:
		- Provision and configure API management service settings.
		- Define or import API schema.
		- Package APIs into products.
		- Setup policies like quotas or transformations on the API.
		- Get insights from analytics.
		- Manage users.
	- Developer portal:
		- Read API documentation.
		- Call an API via the interactive console.
		- Create an account and subscribe to get API keys.
		- Access analytics on their own usage.
		- Download API definitions.
		- Manage API keys.
- Polices:
	- Control flow: conditionally applies policy statements based on the results of the evaluation of Boolean expressions.
	- Forward request: forward request to a backend service.
	- Limit concurrency: prevents executing more than specified number of request at a time.
	- Log to Event Hub: sends messages in the specified format to an Event Hub defined by a Logger entity.
	- Mock response: aborts pipeline execution and return a mocked response.
	- Retry: retries execution of the enclosed policy statements, if and until the condition is met. Execution will repeat at the specified time intervals and up to the specified retry count.
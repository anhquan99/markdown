# Implement containerized solutions
- Azure container registry (ACR)
	- Use cases
		- Scalable orchestration system that manage containerized applications across clusters of host, including K8s, DC/OS and Docker Swarm.
		- Azure services that support building and running applications at scale, including Azure Kubernetes Service (AKS), App Service, Batch, Service Fabric, ...
	- Tier
		- Basic: provide the same with 2 other tiers ( Azure Active Directory authentication integration, image deletion, and webhooks) for learning and lower usage scenarios.
		- Standard: provide increased storage and image throughput.
		- Premium: provide the highest amount of resources, adding feature such as geo-replication for managing a single registry across multiple regions, content trust for image tag signing, and private endpoints to restrict access to the registry.
	- Storage capabilities
		- Encryption-at-rest: Azure automatically encrypts an image before storing it, and decrypts it on the fly.
		- Regional storage: ACR stores data in the region where the registry is created, except for some regions. If a regional outage occurs, the registry data may become unavailable and isn't automatically recovered, this issue is solved by geo-replication.
		- Zone redundancy: premium service tier feature, replicate your registry to a minimum of 3 separate zones in each enabled region.
		- Scalable strage.
	- ACR Tasks 
		- Quick task: build and push a single container image to a container registry on-demand without needing a local Docker Engine installation. Think `docker build`, `docker push` in the cloud.
		- Automatically triggered tasks: build image base on triggers
			- Trigger on source code update: when the code repository updated, an ACR Task creates webhook trigger a build of the container image defined in the repo.
			- Trigger on base image update: when the updated base image is pushed to your registry, or a base image is updated in a public repo, ACR Tasks can automatically build any application image based on it.
			- Trigger on a schedule: useful for running container workloads on a defined schedule, or running maintenance operations or tests on images pushed regularly to your registry.
	- Image platforms
		- Linux:
			- amd64
			- arm
			- arm64
			- 486
		- Windows:
			- amd64
# Implement Azure Service web apps
- Support service
	- Built-in auto-scale support: depending on the usage of the web app, the web service itself can scale up/down or scale out/in.
	- CI/CD
	- Deployment slots
	- App Service on Linux
- Limitations:
	- App Service on Linux is not supported on Shared pricing tier.
- App Service plan defines:
	- OS
	- Region
	- Number of VM instances
	- Size of VM instances
	- Pricing tier (Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3, Isolated, IsolatedV2)
- Runs and scales (except for Free and Shared tier)
	- An app runs on all the VM instances configured in the App Service plan.
	- If multiple apps are in the same App Service plan, they all share the same VM instances.
	- If you have multiple deployment slots for an app, all deployment slots also run on the same VM instances.
	- If you enable diagnostic logs, perform backups, or run WebJobs, they also use CPU cycles and memory on these VM instances.
- Deployment
	- Automated deployment
	- Manual deployment
- Built-in authentication
	- How it works?
		- Authenticates users and clients with the specified identity provider(s)
		- Validates, stores, and refreshes OAuth tokens issued by the configured identity provider(s)
		- Manages the authenticated session
		- Injects identity information into HTTP request headers
# Implement Azure functions
# Develop solution Azure Cosmos DB
- It's a fully managed NoSQL database designed to provide low latency, elastic scalability of throughput, well-defined semantics for data consistency, and high availability.
- Consistency levels
	 ![[Pasted image 20230610211654.png]]
	 - Strong consistency: Users are always guaranteed to read the latest committed write.
	 - Bounded staleness consistency: the reads might lag behind writes by at most "K" versions of an item or by "T" time interval, whichever is reached first.
	 - Session consistency: monotonic reads and writes.
	 - Consistent prefix consistency: if the operation performs on doc_1 and doc_2 you will get doc_1 ver 1 and doc_2 ver 1 or doc_1 ver 2 and doc_2 ver 2 but never doc_1 ver 1 and doc_2 ver 2.
	 - Eventual consistency: there's no guarantee for reads. In the absence of any further writes, the replicas eventually converge. It's the weakest form of consistency.
- Request units (RUs):
	  ![[Pasted image 20230610214109.png]]
	- Represents the system resources such as CPU, IOPS, and memory that are required to perform the database operations supported by Azure Cosmos DB.
	- Azure Cosmos DB account modes:
		- Provisioned throughput mode: you provision the number of RUs for your application.
		- Serverless mode: you get billed for the number of RUs consumed.
		- Autoscale mode
# Develop solution Blob storage
- Azure Blob storage is object storage solution for the cloud. It's optimized for storing massive amounts of unstructured data.
- Types of storage accounts:
	- Standard: general-purpose v2 account.
	- Premium: use SSD
		- Block blob
		- Page blobs
- Access tiers for block blob data:
	- Hot: it's the highest storage costs, but the lowest access cost. New storage accounts are created in the hot tier by default
	- Cool: infrequently accessed and stored for at least 30 days. It has the lower storage costs and higher access costs compare to the hot tier.
	- Archive: only for individual block blobs. It's the highest access costs but lowest storage costs.
- Storage resource types:
	- Storage accounts
	- Containers: is a set of blobs, similar to a directory in a file system.
	- Blobs:
		- Block blobs
		- Append blobs: optimized for append operations. Ideal for logging data.
		- Page blobs: store virtual hard drive (VHD)
- Security feature:
	- Automatically encrypt using Storage Service Encryption (SSE).
	- Manage operations with Azure Active Directory (Azure AD) and Role-Based Access Control (RBAC).
	- Data can be secure in transit between an application and Azure by using Client-Side Encryption, HTTPS, or SMB 3.0.
	- Disk encrypt by using Azure Disk Encryption.
	- Delegate access to the data objects in Azure Storage can be granted using a shared access signature.
- Encryption key management:
	- Customer-managed key.
	- Customer-provided key.
# User authentication and authorization
- Single tenant: only accessible in your tenant.
- Multi tenant: accessible in other tenants.
- Microsoft identity platform:
	- 
# Secure Azure solutions
- Azure key vault is used for storing and accessing secrets.
- Problem solves:
	- Secrets management
	- Key management
	- Certificate management
- Tiers:
	- Standard: encrypts with a software key.
	- Premium: includes hardware security module (HSM) protected keys.
- Benefits:
	- Centralized application secrets
	- Securely store secrets and keys
	- Monitor access and use
	- Simplified administration of application secrets
- Authentication with Azure key vault:
	- Manage identities for Azure resources: assign an identity to the resources that has access to key vault. This is recommended as a best practice.
	- Service principal and certificate: Microsoft is not recommend is approach because the application owner or developer must rotate the certificate.
	- Service principal and secret: another not recommended approach because it's hard to automatically rotate the bootstrap secret that's used to authenticate to key vault.
- Encryption of data in transit: Azure key vault enforces TLS protocol to protect data when it's traveling between Azure key vault and clients.
- Best practices:
	- Use separate key vaults
	- Control access to your vault
	- Backup
	- Logging
	- Recovery options: turn on soft-delete and purge protection if you want to guard against force deletion.
# Azure caching solutions
- Azure cache for Redis
	- Key scenarios:
		- Data cache
		- Content cache
		- Session store
		- Job and message queuing
		- Distributed transactions
# Event-based solutions
- Azure event Grid is a serverless event broker that you can use to integrate applications using events
	- 5 concepts in event grid
		- Event: what happened.
		- Event sources: where the event took place.
		- Topic: the endpoint publishers send events.
		- Event subscriptions: the event router, it can route to multiple handler. Subscriptions are also used by handler to filter incoming request.
		- Event handler: the app or service to handle event.
	- Event schemas:
		- Event schema: use `"content-type" : "application/json; charset=utf-8` 
		- Cloud schema: use `"content-type" : "application/cloudevents+json"`
	- Event delivery durability:
		- Note: event grid doesn't guarantee order for event delivery, so subscribers may receive them out of order.
		- Retry schedule:
			- If error occur when sending event, event grid will consider dropping the event to dead-letter queue or drop the event. The dead-letter queue is not config by default.
			- Event grid will wait for 30 seconds for the response, after 30 seconds the event grid will retry. Event grid uses an exponential backoff retry policy.
		- Retry policy:
			- Maximum number of attempts: must be 1 to 30, default value is 30.
			- Event time to live (TTL): must be 1 to 1440, default value is 1440 minutes.
		- Output batching:
			- Max events per batch
			- Preferred batch size in kilobytes
		- Delayed delivery: if an endpoint experiences delivery failures, event grid begin to delay the delivery and retry.
		- Dead-letter event: after a certain time of retries or TTL, the event is sent to a storage account.
	- Control access to events
		- Build-in roles
			- Event grid subscription reader: lets you read event grid event subscriptions.
			- Event grid subscription contributor: lets you manage event grid event subscription operations.
			- Event grid contributor: lets you create and manage event grid resources.
			- Event grid data sender: lets you send events to event grid topics.
		- Permissions for event subscriptions: for event handler isn't a WebHook (such as an event hub or queue storage)
			- System topics: `/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}`
			- Custom topics: `/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/Microsoft.EventGrid/topics/{topic-name}`
	- Filter events
		- Event type filtering
		- Subject filtering
		- Advanced filtering
# Message-based solutions
- Azure support 2 types of queue mechanism
	- Service Bus queues: is a fully managed enterprise integration message broker, which decouple applications and services.Data is transferred between different applications and services using messages.
		- Consideration when using:
			- Receive messages without having to poll the queue, Service Bus support long-polling receive operation using the TCP-based protocols
			- Required FIFO
			- Automatic duplicate detection
			- Your application process messages as parallel long-running streams (messages are associated with a stream using the session ID property on the message). In this model each node in the consuming node, the node can examine the state of the application stream state using transaction.
			- Required transactional behavior and atomicity when send or receiving multiple messages from a queue.
			- Handle message > 64 KB and < 256 KB.
		- Queues
			- Load-leveling enables producers and consumers to send and receive messages at different rates. The benefit for application or service is it can handle messages at average load instead of peak load.
		- Receive modes:
			- Receive and delete: marks the message is consumed as the consumer request and return it to the consumer. This mode is not for failure tolerance.
			- Peek lock: if the message is unable to process, the Service Bus service abandon the message. Service Bus unlocks the message and make it available to be received again. There is a timeout associated with the lock.
				1. Find the next message to be consumed, lock is it to prevent other consumers from receiving it, then return to the application or service.
				2. After the application or service consumes the message, it will tell the message queue the message has been completed, then the message queue mark the message is consumed.
			- Topics and subscriptions: provide on-to-many form of communication in a publish and subscribe pattern.
			- Rules and actions
	- Storage queues
		- Consideration when using:
			- Store more than 80 GBs of message.
			- Required keeping track of the progress message
# Application insights
- Application insights is an extension of Azure Monitor provides Application Performance Monitoring (APM) tools are useful to monitor applications from development, test, and production in following ways:
	- Proactively understand how an application os performing.
	- Reactively review application execution data to determine the cause of an incident.
- Feature:
	- Live metrics.
	- Availability.
	- Github or Azure DevOps integration.
	- Usage.
	- Smart detection.
	- Application map.
	- Distributed tracing.
- Monitors:
	- Request rates, response times and failure rates.
	- Dependency rates, response times, and failure rates
	- Exceptions.
	- Page views and load performance.
	- AJAX calls.
	- User and session counts.
	- Performance counters.
	- Host diagnostics.
	- Diagnostics trace logs.
	- Custom evnts and metrics.
- Log-based metrics:
	- Log-based metrics are translated into Kusto queries from stored events.
	- Standard metrics are stored as pre-aggregated time series.
- Availability test
	- URL ping test
	- Standard test: include SSL certificate validity, proactive lifetime check.
	- Custom TrackAvailability
	- Multi-step test (only available through Visual Studio 2019)
# API management
- Components:
	- API gateway:
		- Accepts API call and routes them to appropriate backends.
		- Verifies API keys and other credentials presented with requests.
		- Enforces usage quotas and rate limits.
		- Transforms requests and responses specified in policy statements.
		- Caches responses to improve response latency and minimize the load on backend services.
		- Emits log, metrics and traces for monitoring, reporting and troubleshooting.
	- Management plane:
		- Provision and configure API management service settings.
		- Define or import API schema.
		- Package APIs into products.
		- Setup policies like quotas or transformations on the API.
		- Get insights from analytics.
		- Manage users.
	- Developer portal:
		- Read API documentation.
		- Call an API via the interactive console.
		- Create an account and subscribe to get API keys.
		- Access analytics on their own usage.
		- Download API definitions.
		- Manage API keys.
- Polices:
	- Control flow: conditionally applies policy statements based on the results of the evaluation of Boolean expressions.
	- Forward request: forward request to a backend service.
	- Limit concurrency: prevents executing more than specified number of request at a time.
	- Log to Event Hub: sends messages in the specified format to an Event Hub defined by a Logger entity.
	- Mock response: aborts pipeline execution and return a mocked response.
	- Retry: retries execution of the enclosed policy statements, if and until the condition is met. Execution will repeat at the specified time intervals and up to the specified retry count.
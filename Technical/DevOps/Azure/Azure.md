# Implement containerized solutions
- Azure container registry (ACR)
	- Use cases
		- Scalable orchestration system that manage containerized applications across clusters of host, including K8s, DC/OS and Docker Swarm.
		- Azure services that support building and running applications at scale, including Azure Kubernetes Service (AKS), App Service, Batch, Service Fabric, ...
	- Tier
		- Basic: provide the same with 2 other tiers ( Azure Active Directory authentication integration, image deletion, and webhooks) for learning and lower usage scenarios.
		- Standard: provide increased storage and image throughput.
		- Premium: provide the highest amount of resources, adding feature such as geo-replication for managing a single registry across multiple regions, content trust for image tag signing, and private endpoints to restrict access to the registry.
	- Storage capabilities
		- Encryption-at-rest: Azure automatically encrypts an image before storing it, and decrypts it on the fly.
		- Regional storage: ACR stores data in the region where the registry is created, except for some regions. If a regional outage occurs, the registry data may become unavailable and isn't automatically recovered, this issue is solved by geo-replication.
		- Zone redundancy: premium service tier feature, replicate your registry to a minimum of 3 separate zones in each enabled region.
		- Scalable strage.
	- ACR Tasks 
		- Quick task: build and push a single container image to a container registry on-demand without needing a local Docker Engine installation. Think `docker build`, `docker push` in the cloud.
		- Automatically triggered tasks: build image base on triggers
			- Trigger on source code update: when the code repository updated, an ACR Task creates webhook trigger a build of the container image defined in the repo.
			- Trigger on base image update: when the updated base image is pushed to your registry, or a base image is updated in a public repo, ACR Tasks can automatically build any application image based on it.
			- Trigger on a schedule: useful for running container workloads on a defined schedule, or running maintenance operations or tests on images pushed regularly to your registry.
	- Image platforms
		- Linux:
			- amd64
			- arm
			- arm64
			- 486
		- Windows:
			- amd64
# Implement Azure Service web apps
- Support service
	- Built-in auto-scale support: depending on the usage of the web app, the web service itself can scale up/down or scale out/in.
	- CI/CD
	- Deployment slots
	- App Service on Linux
- Limitations:
	- App Service on Linux is not supported on Shared pricing tier.
- App Service plan defines:
	- OS
	- Region
	- Number of VM instances
	- Size of VM instances
	- Pricing tier (Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3, Isolated, IsolatedV2)
- Runs and scales (except for Free and Shared tier)
	- An app runs on all the VM instances configured in the App Service plan.
	- If multiple apps are in the same App Service plan, they all share the same VM instances.
	- If you have multiple deployment slots for an app, all deployment slots also run on the same VM instances.
	- If you enable diagnostic logs, perform backups, or run WebJobs, they also use CPU cycles and memory on these VM instances.
- Deployment
	- Automated deployment
	- Manual deployment
- Built-in authentication
	- How it works?
		- Authenticates users and clients with the specified identity provider(s)
		- Validates, stores, and refreshes OAuth tokens issued by the configured identity provider(s)
		- Manages the authenticated session
		- Injects identity information into HTTP request headers
# Implement Azure functions
# Develop solution Azure Cosmos DB
- It's a fully managed NoSQL database designed to provide low latency, elastic scalability of throughput, well-defined semantics for data consistency, and high availability.
- Consistency levels
	 ![[Pasted image 20230610211654.png]]
	 - Strong consistency: Users are always guaranteed to read the latest committed write.
	 - Bounded staleness consistency: the reads might lag behind writes by at most "K" versions of an item or by "T" time interval, whichever is reached first.
	 - Session consistency: monotonic reads and writes.
	 - Consistent prefix consistency: if the operation performs on doc_1 and doc_2 you will get doc_1 ver 1 and doc_2 ver 1 or doc_1 ver 2 and doc_2 ver 2 but never doc_1 ver 1 and doc_2 ver 2.
	 - Eventual consistency: there's no guarantee for reads. In the absence of any further writes, the replicas eventually converge. It's the weakest form of consistency.
- Request units (RUs):
	  ![[Pasted image 20230610214109.png]]
	- Represents the system resources such as CPU, IOPS, and memory that are required to perform the database operations supported by Azure Cosmos DB.
	- Azure Cosmos DB account modes:
		- Provisioned throughput mode: you provision the number of RUs for your application.
		- Serverless mode: you get billed for the number of RUs consumed.
		- Autoscale mode
# Develop solution Blob storage
- Azure Blob storage is object storage solution for the cloud. It's optimized for storing massive amounts of unstructured data.
- Types of storage accounts:
	- Standard: general-purpose v2 account.
	- Premium: use SSD
		- Block blob
		- Page blobs
- Access tiers for block blob data:
	- Hot: it's the highest storage costs, but the lowest access cost. New storage accounts are created in the hot tier by default
	- Cool: infrequently accessed and stored for at least 30 days. It has the lower storage costs and higher access costs compare to the hot tier.
	- Archive: only for individual block blobs. It's the highest access costs but lowest storage costs.
- Storage resource types:
	- Storage accounts
	- Containers: is a set of blobs, similar to a directory in a file system.
	- Blobs:
		- Block blobs
		- Append blobs: optimized for append operations. Ideal for logging data.
		- Page blobs: store virtual hard drive (VHD)
- Security feature:
	- Automatically encrypt using Storage Service Encryption (SSE).
	- Manage operations with Azure Active Directory (Azure AD) and Role-Based Access Control (RBAC).
	- Data can be secure in transit between an application and Azure by using Client-Side Encryption, HTTPS, or SMB 3.0.
	- Disk encrypt by using Azure Disk Encryption.
	- Delegate access to the data objects in Azure Storage can be granted using a shared access signature.
- Encryption key management:
	- Customer-managed key.
	- Customer-provided key.
# User authentication and authorization
- Single tenant: only accessible in your tenant.
- Multi tenant: accessible in other tenants.
# Secure Azure solutions
- Azure key vault is used for storing and accessing secrets.
- Problem solves:
	- Secrets management
	- Key management
	- Certificate management
- Tiers:
	- Standard: encrypts with a software key.
	- Premium: includes hardware security module (HSM) protected keys.
- Benefits:
	- Centralized application secrets
	- Securely store secrets and keys
	- Monitor access and use
	- Simplified administration of application secrets
- Authentication with Azure key vault:
	- Manage identities for Azure resources: assign an identity to the resources that has access to key vault. This is recommended as a best practice.
	- Service principal and certificate: Microsoft is not recommend is approach because the application owner or developer must rotate the certificate.
	- Service principal and secret: another not recommended approach because it's hard to automatically rotate the bootstrap secret that's used to authenticate to key vault.
- Encryption of data in transit: Azure key vault enforces TLS protocal to protect data when it's traveling between Azure key vault and clients.
- Best practices:
	- Use separate key vaults
	- Control access to your vault
	- Backup
	- Logging
	- Recovery options: turn on soft-delete and purge protection if you want to guard against force deletion.
# Azure caching solutions
- Azure cache for Redis
	- Key scenarios:
		- Data cache
		- Content cache
		- Session store
		- Job and message queuing
		- Distributed transactions
# Event-based solutions
- Azure event Grid is a serverless event broker that you can use to intergrate applications using events
	- 5 concepts in event grid
		- Event: what happened.
		- Event sources: where the event took place.
		- Topic: the endpoint publishers send events.
		- Event subscriptions: the event router, it can route to multiple handler. Subscriptions are also used by handler to filter incoming request.
		- Event handler: the app or service to handle event.
	- Event schemas:
		- Event schema: use `"content-type" : "application/json; charset=utf-8` 
		- Cloud schema: use `"content-type : "application/cloudevents+json"`
	- Event delivery durability:
		- Note: event grid doesn't guarantee order for event delivery, so subscribers may receive them out of order.
		- Retry schedule:
			- If error occur when sending event, event grid will consider dropping the event to dead-letter queue or drop the event. The dead-letter queue is not config by default.
			- Event grid will wait for 30 seconds for the response, after 30 seconds the event grid will retry. Event grid uses an exponential backoff retry policy.
		- Retry policy:
			- Maximum number of attempts: must be 1 to 30, default value is 30.
			- Event time to live (TTL): must be 1 to 1440, default value is 1440 minutes.
		- Output batching:
			- Max events per batch
			- Preferred batch size in kilobytes
		- Delayed delivery: if an endpoint experiences delivery failures, event grid begin to delay the delivery and retry.
		- Dead-letter event: after certain time of retries or TTL, the event is sent to a storage account.
		- 
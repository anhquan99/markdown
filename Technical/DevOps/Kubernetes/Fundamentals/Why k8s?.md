# Problem: **Monolithic applications** 
- Components tightly coupled and almost impossible to separate.
- Expensive taste in hardware. Being a large single piece of software which continuously grows, it has to run on a single system which has to satisfy its compute, memory, storage, and networking requirements. The hardware of such capacity is not only complex and extremely pricey, but at times challenging to procure.
# Solution: **Microservices**
- Deployed individually on separate servers provisioned with fewer resources - only what is required by each service and the host system itself, helping to lower compute resource expenses.
- Aligned with Event-driven architecture and Service-Oriented architecture (SOA) principles, where complex applications are composed of small independent processes which communicate with each other through APIs over a network.
- Flexible when developing with modern programming languages.
- Scalability, application becoming modular, each microservice can be scaled individually.
- Upgrades and patching processes have no downtime and no service disruption.
# Drawbacks
- The distributed nature of microservices adds complexity to the architecture.
